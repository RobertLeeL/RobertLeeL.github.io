<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="AFNetworking 3.2.1如今使用OC进行开发iOS开发的可能都用过AFNetworking网络框架，在github上已经有3W+star,在github上OC开源库中排名第一。 接下来让我们来看看AFNetworking是如何实现的。">
<meta name="keywords" content="0.1">
<meta property="og:type" content="article">
<meta property="og:title" content="AFNetworking源码阅读">
<meta property="og:url" content="http://robertleeng.com/2018/12/18/AFNetworking源码阅读/index.html">
<meta property="og:site_name" content="Robert Lee">
<meta property="og:description" content="AFNetworking 3.2.1如今使用OC进行开发iOS开发的可能都用过AFNetworking网络框架，在github上已经有3W+star,在github上OC开源库中排名第一。 接下来让我们来看看AFNetworking是如何实现的。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://robertleeng.com/img/AFNetWorking.png">
<meta property="og:updated_time" content="2019-02-26T14:24:23.533Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AFNetworking源码阅读">
<meta name="twitter:description" content="AFNetworking 3.2.1如今使用OC进行开发iOS开发的可能都用过AFNetworking网络框架，在github上已经有3W+star,在github上OC开源库中排名第一。 接下来让我们来看看AFNetworking是如何实现的。">
<meta name="twitter:image" content="http://robertleeng.com/img/AFNetWorking.png">






  <link rel="canonical" href="http://robertleeng.com/2018/12/18/AFNetworking源码阅读/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>AFNetworking源码阅读 | Robert Lee</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Robert Lee</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">To Be a Confident Man!</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://robertleeng.com/2018/12/18/AFNetworking源码阅读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Robert Lee">
      <meta itemprop="description" content="Robert Lee的博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Robert Lee">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">AFNetworking源码阅读

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-18 00:47:24" itemprop="dateCreated datePublished" datetime="2018-12-18T00:47:24+08:00">2018-12-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-26 22:24:23" itemprop="dateModified" datetime="2019-02-26T22:24:23+08:00">2019-02-26</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="AFNetworking-3-2-1"><a href="#AFNetworking-3-2-1" class="headerlink" title="AFNetworking 3.2.1"></a>AFNetworking 3.2.1</h3><p>如今使用OC进行开发iOS开发的可能都用过<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a>网络框架，在github上已经有3W+star,在github上OC开源库中排名第一。 接下来让我们来看看<code>AFNetworking</code>是如何实现的。</p>
<a id="more"></a>
<hr>
<h4 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h4><p><img src="/img/AFNetWorking.png" alt="截图"></p>
<p>从图中可以看出，AFNetWorking大致分为五个部分。</p>
<ul>
<li>NSURLSession : 下载器</li>
<li>Reachability : 网络监听</li>
<li>Security : 安全相关</li>
<li>Serialization : 序列化</li>
<li>UIKit : 一些分类</li>
</ul>
<p>接下来我们一步步分析<code>AFNetworking</code>是如何实现的。</p>
<h4 id="AFNetworking-简单使用"><a href="#AFNetworking-简单使用" class="headerlink" title="AFNetworking 简单使用"></a>AFNetworking 简单使用</h4><pre><code>AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
//最大请求并发任务数
manager.operationQueue.maxConcurrentOperationCount = 5;

// 请求格式
// AFHTTPRequestSerializer            二进制格式
// AFJSONRequestSerializer            JSON
// AFPropertyListRequestSerializer    PList(是一种特殊的XML,解析起来相对容易)              
manager.requestSerializer = [AFHTTPRequestSerializer serializer]; // 上传普通格式

// 超时时间
manager.requestSerializer.timeoutInterval = 30.0f;
// 设置请求头
[manager.requestSerializer setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Content-Encoding&quot;];
// 设置接收的Content-Type
manager.responseSerializer.acceptableContentTypes = [[NSSet alloc] initWithObjects:@&quot;application/xml&quot;, @&quot;text/xml&quot;,@&quot;text/html&quot;, @&quot;application/json&quot;,@&quot;text/plain&quot;,nil];

// 返回格式
// AFHTTPResponseSerializer           二进制格式
// AFJSONResponseSerializer           JSON
// AFXMLParserResponseSerializer      XML,只能返回XMLParser,还需要自己通过代理方法解析
// AFXMLDocumentResponseSerializer (Mac OS X)
// AFPropertyListResponseSerializer   PList
// AFImageResponseSerializer          Image
// AFCompoundResponseSerializer       组合

manager.responseSerializer = [AFJSONResponseSerializer serializer];//返回格式 JSON
//设置返回C的ontent-type
manager.responseSerializer.acceptableContentTypes=[[NSSet alloc] initWithObjects:@&quot;application/xml&quot;, @&quot;text/xml&quot;,@&quot;text/html&quot;, @&quot;application/json&quot;,@&quot;text/plain&quot;,nil];
//创建请求地址
NSString *url=@&quot;https://www.tking.cn/showapi/mobile/pub/site/1002/active_show?isSupportSession=1&amp;length=10&amp;locationCityOID=1101&amp;offset=0&amp;seq=desc&amp;siteCityOID=1101&amp;sorting=weight&amp;src=ios&amp;type=6&amp;ver=4.1.0&quot;;
//调用get请求方法
[manager GET:url parameters:nil progress:^(NSProgress * _Nonnull downloadProgress) {
      //返回请求返回进度
      NSLog(@&quot;downloadProgress--&gt;%@&quot;,downloadProgress);
} success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
      //请求成功返回数据 根据responseSerializer 返回不同的数据格式
      NSLog(@&quot;responseObject--&gt;%@&quot;,responseObject);
} failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
      //请求失败
      NSLog(@&quot;error--&gt;%@&quot;,error);
    }];
</code></pre><p>上面就是一次简单的Get请求方法。<br>使用<code>AFHTTPSessionManager</code>就是进行一次请求，接下来让我们一步步研究一下<code>AFNetworking</code>。</p>
<p><strong>我们首先看一下完成一次请求的调用过程</strong></p>
<ul>
<li>AFHTTPSessionManager</li>
</ul>
<pre><code>- (NSURLSessionDataTask *)GET:(NSString *)URLString
                parameters:(id)parameters
                  progress:(void (^)(NSProgress * _Nonnull))downloadProgress
                   success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success
                   failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure;
</code></pre><p>—&gt;<strong>下一步</strong> 生成一个<code>NSURLSessionDataTask</code></p>
<pre><code>- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method
                                   URLString:(NSString *)URLString
                                  parameters:(id)parameters
                              uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress
                            downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress
                                     success:(void (^)(NSURLSessionDataTask *, id))success
                                     failure:(void (^)(NSURLSessionDataTask *, NSError *))failure;
</code></pre><p>—-&gt; <code>AFHTTPRequestSerializer</code> 初始化一个<code>NSMutableURLRequest</code></p>
<pre><code>- (NSMutableURLRequest *)requestWithMethod:(NSString *)method
                             URLString:(NSString *)URLString
                            parameters:(id)parameters
                                 error:(NSError *__autoreleasing *)error;
</code></pre><p>—&gt; <code>AFURLRequestSerialization</code>  配置<code>NSMutableURLRequest</code></p>
<pre><code>- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request
                           withParameters:(id)parameters
                                    error:(NSError *__autoreleasing *)error;
</code></pre><p>—-&gt; <code>AFURLSessionManager</code>  配置<code>NSURLSessionDataTask</code></p>
<pre><code>- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;
</code></pre><p>—&gt; 把<code>dataTask</code>添加到代理中</p>
<pre><code>- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask
                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
</code></pre><h5 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h5><p>先来看一下<code>AFURLSessionManager</code>类的接口文件。</p>
<pre><code>//进行下载的对话
@property (readonly, nonatomic, strong) NSURLSession *session;

//操作队列，当代理进行回调的时候使用
@property (readonly, nonatomic, strong) NSOperationQueue *operationQueue;

//数据解码
@property (nonatomic, strong) id &lt;AFURLResponseSerialization&gt; responseSerializer;

//安全策略
@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;

//网络状态管理
@property (readwrite, nonatomic, strong) AFNetworkReachabilityManager *reachabilityManager;

//正在执行的任务
@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionTask *&gt; *tasks;

//正在执行的data任务
@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDataTask *&gt; *dataTasks;

//正在执行的upload任务
@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionUploadTask *&gt; *uploadTasks;

//正在执行的download任务
@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDownloadTask *&gt; *downloadTasks;

//回调的线程 为空就默认主线程
@property (nonatomic, strong, nullable) dispatch_queue_t completionQueue;

//回调的线程组 为空则使用私有线程组
@property (nonatomic, strong, nullable) dispatch_group_t completionGroup;

//是否在后台重新创建上传任务
@property (nonatomic, assign) BOOL attemptsToRecreateUploadTasksForBackgroundSessions

//初始化session会话
- (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration

//是否取消会话
- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks;

//下面的方法就是创建任务的方法了就不介绍了

//根据任务获取上传进度
- (nullable NSProgress *)uploadProgressForTask:(NSURLSessionTask *)task;

//根据任务获取下载进度
- (nullable NSProgress *)downloadProgressForTask:(NSURLSessionTask *)task;

//下面又是session代理方法的回调了
</code></pre><p>这就是<code>AFURLSessionManager</code>的接口文件，接下来我们看一下实现文件。<br>接口文件一开始就是一些创建线程和线程做的方法，定义一些<code>key</code>和<code>block</code>回调。</p>
<h6 id="AFURLSessionManagerTaskDelegate"><a href="#AFURLSessionManagerTaskDelegate" class="headerlink" title="AFURLSessionManagerTaskDelegate"></a>AFURLSessionManagerTaskDelegate</h6><p>在<code>AFURLSessionManager</code>实现文件中，定义了一个<code>AFURLSessionManagerTaskDelegate</code>类。继承自<code>NSObject</code>遵守了<code>NSURLSession</code>的代理。</p>
<pre><code>//初始化方法
- (instancetype)initWithTask:(NSURLSessionTask *)task;

//持有一个manager 弱引用
@property (nonatomic, weak) AFURLSessionManager *manager;

//存放下载数据
@property (nonatomic, strong) NSMutableData *mutableData;

//上传进度
@property (nonatomic, strong) NSProgress *uploadProgress;

//下载进度
@property (nonatomic, strong) NSProgress *downloadProgress;

//下载失败URL
@property (nonatomic, copy) NSURL *downloadFileURL;

//回调block
@property (nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;
@property (nonatomic, copy) AFURLSessionTaskProgressBlock uploadProgressBlock;
@property (nonatomic, copy) AFURLSessionTaskProgressBlock downloadProgressBlock;
@property (nonatomic, copy) AFURLSessionTaskCompletionHandler completionHandler;
</code></pre><p>初始化方法中，初始化了下载数据、上传下载进度，和为进度添加了一个代理。剩下就是<code>NSURLSession</code>一系列的代理方法。后面再说吧。。<br>TODO:</p>
<hr>
<h6 id="AFURLSessionTaskSwizzling"><a href="#AFURLSessionTaskSwizzling" class="headerlink" title="_AFURLSessionTaskSwizzling"></a>_AFURLSessionTaskSwizzling</h6><p>在<code>AFURLSessionManager</code>实现文件中，还定义了一个<code>_AFURLSessionTaskSwizzling</code>类。这就是Runtime中的黑魔法，进行方法交换。</p>
<pre><code>//交换方法
static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) {
    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);
    method_exchangeImplementations(originalMethod, swizzledMethod);
}

//添加方法
static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) {
    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));
}

//当该类在Runtime编译的时候运行的方法，主要重新写NSURLSession的resume和suspend方法，调用该方法的时候发出代理
+ (void)load {
  //这段代码是解决iOS7、iOS8中的方法，源码中有详细的介绍 就是交换resume方法
    if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) {
        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
        NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;
        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];
#pragma clang diagnostic pop
        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));
        Class currentClass = [localDataTask class];

        while (class_getInstanceMethod(currentClass, @selector(resume))) {
            Class superClass = [currentClass superclass];
            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));
            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));
            if (classResumeIMP != superclassResumeIMP &amp;&amp;
                originalAFResumeIMP != classResumeIMP) {
                [self swizzleResumeAndSuspendMethodForClass:currentClass];
            }
            currentClass = [currentClass superclass];
        }

        [localDataTask cancel];
        [session finishTasksAndInvalidate];
    }
}
</code></pre><h6 id="AFURLSessionManager-1"><a href="#AFURLSessionManager-1" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h6><pre><code>//初始化方法，设置会话的配置
- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {
    self = [super init];
    if (!self) {
        return nil;
    }

    if (!configuration) {
        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
    }

    self.sessionConfiguration = configuration;

    self.operationQueue = [[NSOperationQueue alloc] init];
    self.operationQueue.maxConcurrentOperationCount = 1;

    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];

    self.responseSerializer = [AFJSONResponseSerializer serializer];

    self.securityPolicy = [AFSecurityPolicy defaultPolicy];

#if !TARGET_OS_WATCH
    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];
#endif

    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];

    self.lock = [[NSLock alloc] init];
    self.lock.name = AFURLSessionManagerLockName;

    //把当前session的task 添加到AFURLSessionManagerTaskDelegate中
    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
        for (NSURLSessionDataTask *task in dataTasks) {
            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];
        }

        for (NSURLSessionUploadTask *uploadTask in uploadTasks) {
            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];
        }

        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) {
            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];
        }
    }];

    return self;
}
</code></pre><p>接下来我们看看是如何把当前的<code>task</code>用<code>AFURLSessionManagerTaskDelegate</code>储存的。</p>
<pre><code>- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask
                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
{
    //根据当前的dataTask初始化一个AFURLSessionManagerTaskDelegate
    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];
    delegate.manager = self;
    delegate.completionHandler = completionHandler;

    dataTask.taskDescription = self.taskDescriptionForSessionTasks;
    //把当前的delegate 存入mutableTaskDelegatesKeyedByTaskIdentifier
    [self setDelegate:delegate forTask:dataTask];

    delegate.uploadProgressBlock = uploadProgressBlock;
    delegate.downloadProgressBlock = downloadProgressBlock;
}


- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate
            forTask:(NSURLSessionTask *)task
{
    NSParameterAssert(task);
    NSParameterAssert(delegate);

    //线程锁
    [self.lock lock];
    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;
    //添加监听
    [self addNotificationObserverForTask:task];
    [self.lock unlock];
}

//监听当前的task开始和挂起
- (void)addNotificationObserverForTask:(NSURLSessionTask *)task {
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];
}
</code></pre><p>添加<code>uploadTask</code>和<code>downloadTask</code>方法实现相同，就不介绍了。接下来我们来看上面提到AFNetworking实现的方法。</p>
<pre><code>- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                            completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
{
    return [self dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:completionHandler];
}

- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                           uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
                         downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
                        completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler {

__block NSURLSessionDataTask *dataTask = nil;
//生成dataTask
url_session_manager_create_task_safely(^{
    dataTask = [self.session dataTaskWithRequest:request];
});

//把当前的dataTask封装成delegate 放在mutableTaskDelegatesKeyedByTaskIdentifier中，上面已经介绍过
[self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];

return dataTask;
}
</code></pre><p><code>upload</code>和<code>download</code>方法相似。</p>
<p>获取下载进度：</p>
<pre><code>- (NSProgress *)uploadProgressForTask:(NSURLSessionTask *)task {
    return [[self delegateForTask:task] uploadProgress];
}

- (NSProgress *)downloadProgressForTask:(NSURLSessionTask *)task {
    return [[self delegateForTask:task] downloadProgress];
}

- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task {
NSParameterAssert(task);

AFURLSessionManagerTaskDelegate *delegate = nil;
//线程锁
[self.lock lock];
//从mutableTaskDelegatesKeyedByTaskIdentifier取出当前的delegate
delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];
[self.lock unlock];

return delegate;
}
</code></pre><p>后面还有设置代理回调的block，我就不说了。</p>
<ul>
<li>NSURLSessionDelegate</li>
</ul>
<pre><code>//当前的session为无效的代理
- (void)URLSession:(NSURLSession *)session
didBecomeInvalidWithError:(NSError *)error
{   
    if (self.sessionDidBecomeInvalid) {
        self.sessionDidBecomeInvalid(session, error);
    }
    //发送当前失效的通知
    [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];
}

/*进行HTTPS请求的时候会调用
* 处理服务器返回的证书，需要在该方法中告诉系统是否需要安装证书
* NSURLAuthenticationChallenge : 授权质问
* NSURLSessionAuthChallengeDisposition : 保护控件
* NSURLCredential : 服务器返回的证书
*/
/* 看一下苹果解释：
如果已实现，则在发生连接级别身份验证质询时，此代理将有机会向基础连接提供身份验证凭据。
某些类型的身份验证将应用于与服务器的给定连接上的多个请求（SSL服务器信任质询）。
如果未实现此委托消息，则行为将使用默认处理，这可能涉及用户交互
*/
//这个方法目前没用到过
- (void)URLSession:(NSURLSession *)session
didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler
{
    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;
    __block NSURLCredential *credential = nil;

    //判断当前sessionDidReceiveAuthenticationChallenge回调是否存在存在则回调 不存在这安全策略则进行服务器信任。
    if (self.sessionDidReceiveAuthenticationChallenge) {
        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);
    } else {
        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {
                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
                if (credential) {
                    disposition = NSURLSessionAuthChallengeUseCredential;
                } else {
                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;
                }
            } else {
                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;
            }
        } else {
            disposition = NSURLSessionAuthChallengePerformDefaultHandling;
        }
    }

    if (completionHandler) {
        completionHandler(disposition, credential);
    }
}
</code></pre><ul>
<li>NSURLSessionTaskDelegate</li>
</ul>
<pre><code>// 告诉委托远程服务器请求HTTP重定向。
//此方法仅适用于默认和临时会话中的任务。 后台会话中的任务会自动遵循重定向。
- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
willPerformHTTPRedirection:(NSHTTPURLResponse *)response
        newRequest:(NSURLRequest *)request
 completionHandler:(void (^)(NSURLRequest *))completionHandler
{
    NSURLRequest *redirectRequest = request;

    if (self.taskWillPerformHTTPRedirection) {
        redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request);
    }

    if (completionHandler) {
        completionHandler(redirectRequest);
    }
}


//和上面NSURLSessionDelegate相同
- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler
{
    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;
    __block NSURLCredential *credential = nil;

    if (self.taskDidReceiveAuthenticationChallenge) {
        disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);
    } else {
        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {
                disposition = NSURLSessionAuthChallengeUseCredential;
                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
            } else {
                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;
            }
        } else {
            disposition = NSURLSessionAuthChallengePerformDefaultHandling;
        }
    }

    if (completionHandler) {
        completionHandler(disposition, credential);
    }
}

//当任务需要新的请求主体流发送到远程服务器时，告诉委托。
//这种委托方法在两种情况下被调用：
//1、如果使用uploadTaskWithStreamedRequest创建任务，则提供初始请求正文流：
//2、如果任务因身份验证质询或其他可恢复的服务器错误需要重新发送包含正文流的请求，则提供替换请求正文流。
 注：如果代码使用文件URL或NSData对象提供请求主体，则不需要实现此功能。

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
 needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler
{
    NSInputStream *inputStream = nil;

    if (self.taskNeedNewBodyStream) {
        inputStream = self.taskNeedNewBodyStream(session, task);
    } else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) {
        inputStream = [task.originalRequest.HTTPBodyStream copy];
    }

    if (completionHandler) {
        completionHandler(inputStream);
    }
}

//定期通知代理向服务器发送主体内容的进度。也就是当前的上传进度
- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
   didSendBodyData:(int64_t)bytesSent
    totalBytesSent:(int64_t)totalBytesSent
totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend
{

    int64_t totalUnitCount = totalBytesExpectedToSend;
    if(totalUnitCount == NSURLSessionTransferSizeUnknown) {
        NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@&quot;Content-Length&quot;];
        if(contentLength) {
            totalUnitCount = (int64_t) [contentLength longLongValue];
        }
    }

    //获取当前delegate
    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];

    //如果delegate存在 则调用delegate中的代理方法，回调进度
    if (delegate) {
        [delegate URLSession:session task:task didSendBodyData:bytesSent totalBytesSent:totalBytesSent totalBytesExpectedToSend:totalBytesExpectedToSend];
    }

    //如果block存在则回调
    if (self.taskDidSendBodyData) {
        self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount);
    }
}

//回调任务完成，数据传输完成
- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
didCompleteWithError:(NSError *)error
{
    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];

    // delegate may be nil when completing a task in the background
    if (delegate) {
        [delegate URLSession:session task:task didCompleteWithError:error];

        //移除delegate
        [self removeDelegateForTask:task];
    }

    //回调
    if (self.taskDidComplete) {
        self.taskDidComplete(session, task, error);
    }
}
</code></pre><ul>
<li>NSURLSessionDataDelegate</li>
</ul>
<pre><code>//告诉delegate已经接受到服务器的初始应答, 准备接下来的数据任务的操作.
- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
didReceiveResponse:(NSURLResponse *)response
 completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler
{
    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;

    //回调
    if (self.dataTaskDidReceiveResponse) {
        disposition = self.dataTaskDidReceiveResponse(session, dataTask, response);
    }

    if (completionHandler) {
        completionHandler(disposition);
    }
}


//告诉代理数据任务已更改为下载任务
- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask
{
  //获取delegate
    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];
    if (delegate) {
      //如果delegate存在则移除 储存downloadTask
        [self removeDelegateForTask:dataTask];
        [self setDelegate:delegate forTask:downloadTask];
    }

    //回调
    if (self.dataTaskDidBecomeDownloadTask) {
        self.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask);
    }
}

//收到数据的时候回调
- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
    didReceiveData:(NSData *)data
{
    //获取delegate 并调用delegate中的会话代理方法
    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];
    [delegate URLSession:session dataTask:dataTask didReceiveData:data];

    //回调
    if (self.dataTaskDidReceiveData) {
        self.dataTaskDidReceiveData(session, dataTask, data);
    }
}

//询问委托数据（或上传）任务是否应将响应存储在缓存中。
- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
 willCacheResponse:(NSCachedURLResponse *)proposedResponse
 completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler
{
    NSCachedURLResponse *cachedResponse = proposedResponse;

    if (self.dataTaskWillCacheResponse) {
        cachedResponse = self.dataTaskWillCacheResponse(session, dataTask, proposedResponse);
    }

    if (completionHandler) {
        completionHandler(cachedResponse);
    }
}

//会话进入后台调用的代理
- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session {
    if (self.didFinishEventsForBackgroundURLSession) {
        dispatch_async(dispatch_get_main_queue(), ^{
            self.didFinishEventsForBackgroundURLSession(session);
        });
    }
}
</code></pre><ul>
<li>NSURLSessionDownloadDelegate</li>
</ul>
<pre><code>//下载完成调用存放在临时文件路径
- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location
{   
  //获取当前delegate
    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];
    if (self.downloadTaskDidFinishDownloading) {
      //获取fileURl
        NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);
        if (fileURL) {
            delegate.downloadFileURL = fileURL;
            NSError *error = nil;

            //把临时文件移到目标地址
            if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error]) {
                //发送通知
                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];
            }

            return;
        }
    }

    if (delegate) {
      //调用delegate中的代理方法················
        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];
    }

    //下载进度代理方法
    - (void)URLSession:(NSURLSession *)session
          downloadTask:(NSURLSessionDownloadTask *)downloadTask
          didWriteData:(int64_t)bytesWritten
     totalBytesWritten:(int64_t)totalBytesWritten
    totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
    {

        AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];
        //调用delegate中的代理方法················
        if (delegate) {
            [delegate URLSession:session downloadTask:downloadTask didWriteData:bytesWritten totalBytesWritten:totalBytesWritten totalBytesExpectedToWrite:totalBytesExpectedToWrite];
        }

        //回调
        if (self.downloadTaskDidWriteData) {
            self.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
        }
    }

    //断点续下载
    - (void)URLSession:(NSURLSession *)session
          downloadTask:(NSURLSessionDownloadTask *)downloadTask
     didResumeAtOffset:(int64_t)fileOffset
    expectedTotalBytes:(int64_t)expectedTotalBytes
    {

        AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];

        if (delegate) {
            [delegate URLSession:session downloadTask:downloadTask didResumeAtOffset:fileOffset expectedTotalBytes:expectedTotalBytes];
        }

        if (self.downloadTaskDidResume) {
            self.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes);
        }
    }
</code></pre><p>这就是<code>AFURLSessionManager</code>完整的实现文件。作用很明显</p>
<blockquote>
<blockquote>
<p>1、创建管理NSURLSession<br>2、管理所有Task<br>3、实现 NSURLSessionDelegate 等协议中的代理方法<br>4、引入安全策略和网络监听等</p>
</blockquote>
</blockquote>
<h4 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h4><p><code>AFHTTPSessionManager</code>是继承自<code>AFURLSessionManager</code>，<code>AFHTTPSessionManager</code>也是<code>AFNetworking</code>的入口，调用该类中的方法进行请求。该类遵守了安全编码和复制协议，我们先来看看接口文件。</p>
<pre><code>//请求链接
@property (readonly, nonatomic, strong, nullable) NSURL *baseURL;

//请求格式，后面会讲这个类
@property (nonatomic, strong) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;

//请求接受的内容类型
@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;

//安全策略
@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;

//初始化方法
+ (instancetype)manager;

- (instancetype)initWithBaseURL:(nullable NSURL *)url;

- (instancetype)initWithBaseURL:(nullable NSURL *)url
       sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration;

//get请求 参数就不介绍了
- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString
                   parameters:(nullable id)parameters
                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;

//带下载进度的get请求                      
- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString
                            parameters:(nullable id)parameters
                              progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress
                               success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
                               failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;

//head请求
- (nullable NSURLSessionDataTask *)HEAD:(NSString *)URLString
                    parameters:(nullable id)parameters
                       success:(nullable void (^)(NSURLSessionDataTask *task))success
                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;

//post请求                       
- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString
                    parameters:(nullable id)parameters
                       success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;

//带下载进度的post请求
- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString
                             parameters:(nullable id)parameters
                               progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress
                                success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;

//它接受一个参数并将数据附加到HTTP正文。 block参数是采用`AFMultipartFormData`协议的对象。
- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString
                    parameters:(nullable id)parameters
     constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block
                       success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;

//带下载进度                       
- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString
                             parameters:(nullable id)parameters
              constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block
                               progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress
                                success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;

//put请求
- (nullable NSURLSessionDataTask *)PUT:(NSString *)URLString
                   parameters:(nullable id)parameters
                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;
</code></pre><p>下面还有一个<code>patch</code>请求 和<code>delete</code>请求就不写了快吐了。这就是接口文件，定义了一系列请求方法，接下来看一看实现文件。</p>
<ul>
<li>初始化</li>
</ul>
<pre><code>+ (instancetype)manager {
    return [[[self class] alloc] initWithBaseURL:nil];
}

- (instancetype)init {
    return [self initWithBaseURL:nil];
}

- (instancetype)initWithBaseURL:(NSURL *)url {
    return [self initWithBaseURL:url sessionConfiguration:nil];
}

- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {
    return [self initWithBaseURL:nil sessionConfiguration:configuration];
}

- (instancetype)initWithBaseURL:(NSURL *)url
           sessionConfiguration:(NSURLSessionConfiguration *)configuration
{
    self = [super initWithSessionConfiguration:configuration];
    if (!self) {
        return nil;
    }

    // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected
    if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) {
        url = [url URLByAppendingPathComponent:@&quot;&quot;];
    }

    self.baseURL = url;

    self.requestSerializer = [AFHTTPRequestSerializer serializer];
    self.responseSerializer = [AFJSONResponseSerializer serializer];

    return self;
}

//设置请求序列化
- (void)setRequestSerializer:(AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; *)requestSerializer {
    NSParameterAssert(requestSerializer);

    _requestSerializer = requestSerializer;
}

//设置返回数据序列化
- (void)setResponseSerializer:(AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; *)responseSerializer {
    NSParameterAssert(responseSerializer);

    [super setResponseSerializer:responseSerializer];
}
</code></pre><p>还可以设置安全策略,就不在这提了,接下来我们看一下请求实现过程.</p>
<pre><code>- (NSURLSessionDataTask *)POST:(NSString *)URLString
                    parameters:(id)parameters
                      progress:(void (^)(NSProgress * _Nonnull))uploadProgress
                       success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success
                       failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure
{
    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;POST&quot; URLString:URLString parameters:parameters uploadProgress:uploadProgress downloadProgress:nil success:success failure:failure];

    [dataTask resume];

    return dataTask;
}
</code></pre><p>首先根据参数生成一个dataTask然后在运行当前dataTask如何生成当前datatask已经在上文提打过。这里就不多介绍了。 Get、Head方法实现方式差不多这里就不过多介绍了，后面就是实现编解码和NScopying协议的方法了，就不介绍了。</p>
<h3 id="AFURLSerialization"><a href="#AFURLSerialization" class="headerlink" title="AFURLSerialization"></a>AFURLSerialization</h3><p><code>AFURLSerialization</code>的工作是对发出的HTTP请求进行处理，<code>AFURLRequestSerialization</code>只是一个协议，主要是为<code>AFHTTPRequestSerializer</code>服务。该类的功能如下：</p>
<ul>
<li>1、处理查询的URL参数</li>
<li>2、设置HTTP请求头部字段</li>
<li>3、设置请求的参数</li>
<li>4、分块上传</li>
</ul>
<h4 id="处理参数"><a href="#处理参数" class="headerlink" title="处理参数"></a>处理参数</h4><p><code>AFQueryStringPair</code>该类负责处理参数。</p>
<pre><code>@interface AFQueryStringPair : NSObject
@property (readwrite, nonatomic, strong) id field;
@property (readwrite, nonatomic, strong) id value;

- (instancetype)initWithField:(id)field value:(id)value;

- (NSString *)URLEncodedStringValue;
</code></pre><p><code>- (NSString *)URLEncodedStringValue;</code>方法会返回field=Value这种格式，同时在<code>AFPercentEscapedStringFromString</code>方法中对field和value进行处理，把特殊字符转义。最后在<code>AFHTTPRequestSerializer</code>类中通过<code>AFQueryStringPairsFromKeyAndValue</code>方法中，把查询参数转化为<code>para=value&amp;para=value</code>格式。</p>
<h4 id="设置请求字段头部"><a href="#设置请求字段头部" class="headerlink" title="设置请求字段头部"></a>设置请求字段头部</h4><pre><code>- (void)setValue:(NSString *)value
forHTTPHeaderField:(NSString *)field
{
    dispatch_barrier_async(self.requestHeaderModificationQueue, ^{
        [self.mutableHTTPRequestHeaders setValue:value forKey:field];
    });
}

- (NSString *)valueForHTTPHeaderField:(NSString *)field {
    NSString __block *value;
    dispatch_sync(self.requestHeaderModificationQueue, ^{
        value = [self.mutableHTTPRequestHeaders valueForKey:field];
    });
    return value;
}
</code></pre><p>请求头部字段都会储存在<code>self.mutableHTTPRequestHeaders</code>这个可变字典中。</p>
<pre><code>- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username
                                       password:(NSString *)password
{
    NSData *basicAuthCredentials = [[NSString stringWithFormat:@&quot;%@:%@&quot;, username, password] dataUsingEncoding:NSUTF8StringEncoding];
    NSString *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0];
    [self setValue:[NSString stringWithFormat:@&quot;Basic %@&quot;, base64AuthCredentials] forHTTPHeaderField:@&quot;Authorization&quot;];
}
</code></pre><p>还可以设置验证请求字段。</p>
<h4 id="设置请求的参数"><a href="#设置请求的参数" class="headerlink" title="设置请求的参数"></a>设置请求的参数</h4><pre><code>@property (nonatomic, assign) BOOL allowsCellularAccess;

@property (nonatomic, assign) NSURLRequestCachePolicy cachePolicy;

@property (nonatomic, assign) BOOL HTTPShouldHandleCookies;

@property (nonatomic, assign) BOOL HTTPShouldUsePipelining;

@property (nonatomic, assign) BOOL HTTPShouldUsePipelining;

@property (nonatomic, assign) NSTimeInterval timeoutInterval;
</code></pre><p>在该类中都会添加KVO来监听这些属性的变化，当属性变化的时候会触发监听方法，在生成Request的时候进行设置。</p>
<h4 id="分块上传"><a href="#分块上传" class="headerlink" title="分块上传"></a>分块上传</h4><p>分块上传是通过<code>AFMultipartFormData</code>协议进行上传，这里就不过多介绍了。</p>
<h3 id="AFURLResponseSerialization"><a href="#AFURLResponseSerialization" class="headerlink" title="AFURLResponseSerialization"></a>AFURLResponseSerialization</h3><p>该协议对响应的数据进行解析，<code>AFHTTPResponseSerializer</code>、<code>AFJSONResponseSerializer</code>都遵守了该协议。</p>
<pre><code>@protocol AFURLResponseSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;


- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response
                           data:(nullable NSData *)data
                          error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;

@end
</code></pre><p>遵循这个协议的类同时也要遵循 NSObject、NSSecureCoding 和 NSCopying 这三个协议，实现安全编码、拷贝以及 Objective-C 对象的基本行为。就是对返回数据的解析，这里就不过多介绍了。</p>
<p>判断网络状态<code>AFNetworkReachabilityManager</code>,我会在后面的网站解释。这里就写到这里了。也是大致对AFnetworking有了一定的了解。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://draveness.me/afnetworking3#AFURLResponseSerialization" target="_blank" rel="noopener">处理请求和响应 AFURLSerialization</a></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/0-1/" rel="tag"># 0.1</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/18/SDWebImage源码阅读/" rel="next" title="SDWebImage源码阅读">
                <i class="fa fa-chevron-left"></i> SDWebImage源码阅读
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/24/iOS多线程开发-NSOperation/" rel="prev" title="iOS多线程开发_NSOperation">
                iOS多线程开发_NSOperation <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Robert Lee</p>
              <p class="site-description motion-element" itemprop="description">Robert Lee的博客</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#AFNetworking-3-2-1"><span class="nav-number">1.</span> <span class="nav-text">AFNetworking 3.2.1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AFNetworking"><span class="nav-number">1.1.</span> <span class="nav-text">AFNetworking</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AFNetworking-简单使用"><span class="nav-number">1.2.</span> <span class="nav-text">AFNetworking 简单使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AFURLSessionManager"><span class="nav-number">1.2.1.</span> <span class="nav-text">AFURLSessionManager</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#AFURLSessionManagerTaskDelegate"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">AFURLSessionManagerTaskDelegate</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#AFURLSessionTaskSwizzling"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">_AFURLSessionTaskSwizzling</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#AFURLSessionManager-1"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">AFURLSessionManager</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AFHTTPSessionManager"><span class="nav-number">1.3.</span> <span class="nav-text">AFHTTPSessionManager</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AFURLSerialization"><span class="nav-number">2.</span> <span class="nav-text">AFURLSerialization</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#处理参数"><span class="nav-number">2.1.</span> <span class="nav-text">处理参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置请求字段头部"><span class="nav-number">2.2.</span> <span class="nav-text">设置请求字段头部</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置请求的参数"><span class="nav-number">2.3.</span> <span class="nav-text">设置请求的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分块上传"><span class="nav-number">2.4.</span> <span class="nav-text">分块上传</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AFURLResponseSerialization"><span class="nav-number">3.</span> <span class="nav-text">AFURLResponseSerialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文章"><span class="nav-number">4.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Robert Lee</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
