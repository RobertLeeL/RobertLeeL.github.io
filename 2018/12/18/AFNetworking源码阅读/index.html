<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="AFNetworking 3.2.1如今使用OC进行开发iOS开发的可能都用过AFNetworking网络框架，在github上已经有3W+star,在github上OC开源库中排名第一。 接下来让我们来看看AFNetworking是如何实现的。">
<meta name="keywords" content="0.1">
<meta property="og:type" content="article">
<meta property="og:title" content="AFNetworking源码阅读">
<meta property="og:url" content="http://robertleeng.com/2018/12/18/AFNetworking源码阅读/index.html">
<meta property="og:site_name" content="Robert Lee">
<meta property="og:description" content="AFNetworking 3.2.1如今使用OC进行开发iOS开发的可能都用过AFNetworking网络框架，在github上已经有3W+star,在github上OC开源库中排名第一。 接下来让我们来看看AFNetworking是如何实现的。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://robertleeng.com/img/系统网络编程类关系.png">
<meta property="og:image" content="http://robertleeng.com/img/NSURLSessionTask.png">
<meta property="og:image" content="http://robertleeng.com/img/AFNetWorking.png">
<meta property="og:updated_time" content="2019-01-03T14:13:14.283Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AFNetworking源码阅读">
<meta name="twitter:description" content="AFNetworking 3.2.1如今使用OC进行开发iOS开发的可能都用过AFNetworking网络框架，在github上已经有3W+star,在github上OC开源库中排名第一。 接下来让我们来看看AFNetworking是如何实现的。">
<meta name="twitter:image" content="http://robertleeng.com/img/系统网络编程类关系.png">






  <link rel="canonical" href="http://robertleeng.com/2018/12/18/AFNetworking源码阅读/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>AFNetworking源码阅读 | Robert Lee</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Robert Lee</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">To Be a Confident Man!</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://robertleeng.com/2018/12/18/AFNetworking源码阅读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Robert Lee">
      <meta itemprop="description" content="Robert Lee的博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Robert Lee">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">AFNetworking源码阅读

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-18 00:47:24" itemprop="dateCreated datePublished" datetime="2018-12-18T00:47:24+08:00">2018-12-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-03 22:13:14" itemprop="dateModified" datetime="2019-01-03T22:13:14+08:00">2019-01-03</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="AFNetworking-3-2-1"><a href="#AFNetworking-3-2-1" class="headerlink" title="AFNetworking 3.2.1"></a>AFNetworking 3.2.1</h3><p>如今使用OC进行开发iOS开发的可能都用过<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a>网络框架，在github上已经有3W+star,在github上OC开源库中排名第一。 接下来让我们来看看<code>AFNetworking</code>是如何实现的。</p>
<a id="more"></a>
<hr>
<p>在介绍<code>AFNetworking</code>之前，先看一看苹果提供的原生网络框架的使用。<br>下面这张图介绍了原生提供网络编程的类之间的关系：<br><img src="/img/系统网络编程类关系.png" alt="截图"></p>
<p>我们首先介绍一下各个类：</p>
<ul>
<li>NSURL<br><code>URL</code>的全称是 <code>Uniform Resource Locator</code>意思是统一资源定位符，URL 采用 ASCII 编码格式，所以不支持如中文等非 ASCII 码字符。意思就像是人的身份证一样，可以根据身份证号码定位到一个人。</li>
<li>NSURLRequest<br><code>NSURLRequest</code>通过一个<code>NSUR</code>L来创建一个请求对象，一个<code>NSURLRequest</code>就是一个请求。我们来看一下NSURLRequest中有哪些常用方法。</li>
</ul>
<pre><code>//类方法；根据一个URl创建请求，使用默认缓存NSURLRequestUseProtocolCachePolicy和默认超时相应时间60秒
+ (instancetype)requestWithURL:(NSURL *)URL;

//类方法；根据URL缓存策略和超时相应时间创建请求
+ (instancetype)requestWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval;

//实例方法；根据一个URl创建请求，使用默认缓存NSURLRequestUseProtocolCachePolicy和默认超时相应时间60秒
- (instancetype)initWithURL:(NSURL *)URL;

//实例方法；根据URL缓存策略和超时相应时间创建请求
- (instancetype)initWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval NS_DESIGNATED_INITIALIZER;

//缓存策略有如下几种：
typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)
{
//如果有缓存则进行其他操作，如果没有缓存则从服务端获取
NSURLRequestUseProtocolCachePolicy = 0,

//忽略本地缓存 直接从服务端获取
NSURLRequestReloadIgnoringLocalCacheData = 1,

//忽略本地缓存、代理服务器缓存、直接从服务器获取 目前还没有实现
NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, // Unimplemented

//已被第二种缓存策略取代
NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData,

//有缓存就用 不论失效与否 没有服务端请求
NSURLRequestReturnCacheDataElseLoad = 2,

//只加载本地缓存，没有就返回失败
NSURLRequestReturnCacheDataDontLoad = 3,

//缓存数据服务端确认有效后使用
NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented
};
</code></pre><p><code>NSURLRequest</code>对象是一个请求，包含了发送给服务器的所以信息，包括：</p>
<pre><code>//请求的方法
@property (nullable, readonly, copy) NSString *HTTPMethod;

//请求头文件
@property (nullable, readonly, copy) NSDictionary&lt;NSString *, NSString *&gt; *allHTTPHeaderFields;

//请求体
@property (nullable, readonly, copy) NSData *HTTPBody;
</code></pre><p>但是这些属性都是readonly的，所以<code>NSURLRequest</code>中还声明了<code>NSMutableURLRequest</code>的一个分类，这个分类中可以设置这些属性。</p>
<hr>
<h3 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h3><p><code>NSURLConnection</code>这个类以及被苹果公司废弃了，好像是在iOS9的时候废弃的，使用`NSURLSession这个类代替。在这里简单介绍一下使用方法。</p>
<p>使用<code>NSURLConnection</code>发送一个请求大致分为三步：</p>
<ul>
<li>1、创建一个<code>NSURL</code>对象，设置请求的路径。</li>
<li>2、根据<code>NSURL</code>创建一个<code>NSURLRequest</code>请求。</li>
<li>3、使用<code>NSURLConnection</code>向服务器发送请求。</li>
</ul>
<p><strong>读完官方文档才知道<a href="https://developer.apple.com/documentation/foundation/nsurlconnection?language=objc" target="_blank" rel="noopener">NSURLConnection</a>真的是废弃了很多方法，那我就重新学一遍<code>NSURLConnection</code>,再回忆一下用法。</strong></p>
<p><code>NSURLConnection</code>创建了2个分类，分别发送同步和异步请求。<br><strong>下载这两种发现在iOS9以后就被废弃了，已经被<code>NSURLSession</code>中的方法取代，但是iOS有向下兼容行，使用只会提示警告，而不是报错</strong></p>
<pre><code>/*发送同步请求，这个会阻塞线程知道服务器返回数据为止
*request : 请求
*response : 付不起返回的URL响应头消息
*error : 返回错误信息
*/
+ (nullable NSData *)sendSynchronousRequest:(NSURLRequest *)request returningResponse:(NSURLResponse * _Nullable * _Nullable)response error:(NSError **)error;

/*异步请求，不会阻塞线程
*queue : 异步操作队列
*handler : 回调blog
*/
+ (void)sendAsynchronousRequest:(NSURLRequest*) request
                        queue:(NSOperationQueue*) queue
            completionHandler:(void (^)(NSURLResponse* _Nullable response, NSData* _Nullable data, NSError* _Nullable connectionError)) handle;


NSURL *url = [NSURL URLWithString:@&quot;https://api.seniverse.com/v3/weather/now.json?key=your_api_key&amp;location=beijing&amp;language=zh-Hans&amp;unit=c&quot;];
NSURLRequest *request = [NSURLRequest requestWithURL:url];
NSError *error = nil;
NSURLResponse *response = nil;
//同步请求使用方法  
NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];
//异步请求方法
[NSURLConnection sendAsynchronousRequest:request queue:[[NSOperationQueue alloc] init] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) {

}];
NSLog(@&quot;data:%@&quot;,data);
NSLog(@&quot;error:%@&quot;,error);
NSLog(@&quot;response:%@&quot;,response);
//控制台打印了返回的数据和错误信息 代码太多就不写了
</code></pre><p>**除此之外，还可以使用delegate进行数据请求。</p>
<h4 id="NSURLConnectionDelegate"><a href="#NSURLConnectionDelegate" class="headerlink" title="NSURLConnectionDelegate"></a>NSURLConnectionDelegate</h4><pre><code>//这些代理方法 主要涉及 SSL/TSL加密的相关接口。
//这些代理方法我都没用使用过，所以说的也不是太全面
@protocol NSURLConnectionDelegate &lt;NSObject&gt;
@optional
//如果在资源加载期间发生错误，将最多调用一次。之后不会再进行其他回调，如：请求超时
- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error;
- (BOOL)connectionShouldUseCredentialStorage:(NSURLConnection *)connection;
- (void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;
- (BOOL)connection:(NSURLConnection *)connection canAuthenticateAgainstProtectionSpace:(NSURLProtectionSpace *)protectionSpace ;
- (void)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge ;
- (void)connection:(NSURLConnection *)connection didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;
@end
</code></pre><p>有兴趣的可以看一下苹果官方文档： <a href="https://developer.apple.com/documentation/foundation/nsurlconnectiondelegate?language=objc" target="_blank" rel="noopener">NSURLConnectionDelegate</a></p>
<h4 id="NSURLConnectionDataDelegate"><a href="#NSURLConnectionDataDelegate" class="headerlink" title="NSURLConnectionDataDelegate"></a>NSURLConnectionDataDelegate</h4><p>该代理监听了服务器返回的数据，继承自<code>NSURLConnectionDelegate</code>代理。这个&lt;&gt;是代理继承的意思，我也是刚知道不久。</p>
<pre><code>@protocol NSURLConnectionDataDelegate &lt;NSURLConnectionDelegate&gt;
@optional
//在发送请求之前的代理方法，重定义响应的response
- (nullable NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(nullable NSURLResponse *)response;

//开始接受到服务器的响应时调用
- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;

//接受到服务器返回的数据时调用
- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data;

//发送完请求结构体是调用的数据,接受数据的过程。类似于HTTP post请求
- (nullable NSInputStream *)connection:(NSURLConnection *)connection needNewBodyStream:(NSURLRequest *)request;
- (void)connection:(NSURLConnection *)connection   didSendBodyData:(NSInteger)bytesWritten
                                                 totalBytesWritten:(NSInteger)totalBytesWritten
                                         totalBytesExpectedToWrite:(NSInteger)totalBytesExpectedToWrite;

//在连接将缓存的响应存储在缓存中之前发送，以便为委托者提供更改它的机会。
- (nullable NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;

//服务器返回的数据已经完全接受时调用
- (void)connectionDidFinishLoading:(NSURLConnection *)connection;
</code></pre><p><code>NSURLConnection</code>类提供了3个方法。</p>
<pre><code>//三种方法的第一个参数都是一个请求，第二个为代理，第一个方法的第三个参数表示是否立即请求，若设置为NO,则需要调用start方法

- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate startImmediately:(BOOL)startImmediately;

- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate;

+ (nullable NSURLConnection*)connectionWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate;
</code></pre><h3 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h3><p><code>NSURLSession</code>是iOS7中的网络接口。它与<code>NSURLConnection</code>不同的是支持后台下载操作，以及断点续传功能。如上面的结构图所示，先来看看上面提到的类的作用</p>
<ul>
<li><code>NSURLSessionCofiguration</code> : 定义和配置会话，配置有：Cookie、安全性、缓存策略等等。</li>
<li><code>NSURLSessionDataTask</code>、<code>NSURLSessionDownloadTask</code>、<code>NSURLSessionUploadTask</code> ： 主要负责处理数据的加载，和服务端之间的数据下载和上传任务。他们的<code>supreClass</code>都是<code>NSURLSessionTask</code>,<code>NSURLSessionTask</code>是一个抽象类。<br>它们之间的关系如图所示：</li>
</ul>
<p><img src="/img/NSURLSessionTask.png" alt="截图"></p>
<p>从图中可以看出来，<code>NSURLSessionDataTask</code>和<code>NSURLSessionDownloadTask</code>继承自<code>NSURLSessionTask</code>，而<code>NSURLSessionUploadTask</code>继承自<code>NSURLSessionDataTask</code>。</p>
<p><code>NSURLSessionDataTask</code>：用于处理一般的NSData类型的数据，不支持后台下载。<br><code>NSURLSessionDownloadTask</code> ： 用于下载文件，支持后台下载<br><code>NSURLSessionUploadTask</code> ： 用于PUT方法上传文件，支持后台上传。</p>
<p>接下来让我们一个类一个类进行分析，来看看<code>NSURLSession</code>实现上传和下载。</p>
<h4 id="NSURLSessionConfiguration-类"><a href="#NSURLSessionConfiguration-类" class="headerlink" title="NSURLSessionConfiguration 类"></a>NSURLSessionConfiguration 类</h4><p><code>NSURLSessionConfiguration</code>提供了三种方法获取获取配置实例</p>
<pre><code>//获取默认配置，在创建默认会话时使用。
@property (class, readonly, strong) NSURLSessionConfiguration *defaultSessionConfiguration;

//获取短暂配置， 在创建短暂会话时使用，使用短暂配置就是不存储数据在磁盘上，全部数据都通过缓存保存，当会话结束时，释放
@property (class, readonly, strong) NSURLSessionConfiguration *ephemeralSessionConfiguration;

//创建后台会话配置，会话可以在后台下载上传数据 iOS8以后才可以使用
+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier;
</code></pre><p>在<code>NSURLSessionConfiguration</code>中还定义了很多配置。包括:</p>
<pre><code>//请求缓存策略
@property NSURLRequestCachePolicy requestCachePolicy;

//请求超时时间
@property NSTimeInterval timeoutIntervalForRequest;

//资源超时时间
@property NSTimeInterval timeoutIntervalForResource;

//网络服务类型
@property NSURLRequestNetworkServiceType networkServiceType

//是否使用蜂窝数据
@property BOOL allowsCellularAccess;

//任务等待连接成功再执行 iOS11才可以使用
@property BOOL waitsForConnectivity;

//这里就介绍这么多，后面还有设置Cookies、安全策略、网络缓存等等。我都没用过（仅仅表示我都，所以我很菜/(ㄒoㄒ)/~~），哈哈哈哈哈。所以我慢慢看，后面再补充吧。
</code></pre><h4 id="NSURLSession-类"><a href="#NSURLSession-类" class="headerlink" title="NSURLSession 类"></a>NSURLSession 类</h4><p><code>NSURLSession</code>有三种创建方式</p>
<pre><code>//静态创建会话 会话使用全局的cache、cookies和证书
@property (class, readonly, strong) NSURLSession *sharedSession;

//创建对应配置的会话
+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;

//可以定制的会话，还可以指定delegate 并设置delegate的队列
+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue;
</code></pre><p>在<code>NSURLSession</code>可以获得task执行会话</p>
<pre><code>//请求走代理
/* Creates a data task with the given request.  The request may have a body stream. */
- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request;

/* Creates a data task to retrieve the contents of the given URL. */
- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url

//请求不走代理
- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler;
- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler;

//上传
/* Creates an upload task with the given request.  The body of the request will be created from the file referenced by fileURL */
- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL;

/* Creates an upload task with the given request.  The body of the request is provided from the bodyData. */
- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData;


/*
 * upload convenience method.
 */
- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler;
- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler;


//通过一个request创建下载任务
- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler;

//通过一个URL创建下载任务
- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler;

//实现断点续传
- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler;
</code></pre><p>还有NSURLSession的代理方法进行回调。这些等看完AFNetwroking之后专门写一篇文章解读一下。</p>
<hr>
<h4 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h4><p><img src="/img/AFNetWorking.png" alt="截图"></p>
<p>从图中可以看出，AFNetWorking大致分为五个部分。</p>
<ul>
<li>NSURLSession : 下载器</li>
<li>Reachability : 网络监听</li>
<li>Security : 安全相关</li>
<li>Serialization : 序列化</li>
<li>UIKit : 一些分类</li>
</ul>
<p>接下来我们一步步分析<code>AFNetworking</code>是如何实现的。</p>
<h4 id="AFNetworking-简单使用"><a href="#AFNetworking-简单使用" class="headerlink" title="AFNetworking 简单使用"></a>AFNetworking 简单使用</h4><pre><code>AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
//最大请求并发任务数
manager.operationQueue.maxConcurrentOperationCount = 5;

// 请求格式
// AFHTTPRequestSerializer            二进制格式
// AFJSONRequestSerializer            JSON
// AFPropertyListRequestSerializer    PList(是一种特殊的XML,解析起来相对容易)              
manager.requestSerializer = [AFHTTPRequestSerializer serializer]; // 上传普通格式

// 超时时间
manager.requestSerializer.timeoutInterval = 30.0f;
// 设置请求头
[manager.requestSerializer setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Content-Encoding&quot;];
// 设置接收的Content-Type
manager.responseSerializer.acceptableContentTypes = [[NSSet alloc] initWithObjects:@&quot;application/xml&quot;, @&quot;text/xml&quot;,@&quot;text/html&quot;, @&quot;application/json&quot;,@&quot;text/plain&quot;,nil];

// 返回格式
// AFHTTPResponseSerializer           二进制格式
// AFJSONResponseSerializer           JSON
// AFXMLParserResponseSerializer      XML,只能返回XMLParser,还需要自己通过代理方法解析
// AFXMLDocumentResponseSerializer (Mac OS X)
// AFPropertyListResponseSerializer   PList
// AFImageResponseSerializer          Image
// AFCompoundResponseSerializer       组合

manager.responseSerializer = [AFJSONResponseSerializer serializer];//返回格式 JSON
//设置返回C的ontent-type
manager.responseSerializer.acceptableContentTypes=[[NSSet alloc] initWithObjects:@&quot;application/xml&quot;, @&quot;text/xml&quot;,@&quot;text/html&quot;, @&quot;application/json&quot;,@&quot;text/plain&quot;,nil];
//创建请求地址
NSString *url=@&quot;https://www.tking.cn/showapi/mobile/pub/site/1002/active_show?isSupportSession=1&amp;length=10&amp;locationCityOID=1101&amp;offset=0&amp;seq=desc&amp;siteCityOID=1101&amp;sorting=weight&amp;src=ios&amp;type=6&amp;ver=4.1.0&quot;;
//调用get请求方法
[manager GET:url parameters:nil progress:^(NSProgress * _Nonnull downloadProgress) {
      //返回请求返回进度
      NSLog(@&quot;downloadProgress--&gt;%@&quot;,downloadProgress);
} success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
      //请求成功返回数据 根据responseSerializer 返回不同的数据格式
      NSLog(@&quot;responseObject--&gt;%@&quot;,responseObject);
} failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
      //请求失败
      NSLog(@&quot;error--&gt;%@&quot;,error);
    }];
</code></pre><p>上面就是一次简单的Get请求方法。<br>使用<code>AFHTTPSessionManager</code>就是进行一次请求，接下来让我们一步步研究一下<code>AFNetworking</code>。</p>
<p><strong>我们首先看一下完成一次请求的调用过程</strong></p>
<ul>
<li>AFHTTPSessionManager</li>
</ul>
<pre><code>- (NSURLSessionDataTask *)GET:(NSString *)URLString
                parameters:(id)parameters
                  progress:(void (^)(NSProgress * _Nonnull))downloadProgress
                   success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success
                   failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure;
</code></pre><p>—&gt;<strong>下一步</strong> 生成一个<code>NSURLSessionDataTask</code></p>
<pre><code>- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method
                                   URLString:(NSString *)URLString
                                  parameters:(id)parameters
                              uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress
                            downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress
                                     success:(void (^)(NSURLSessionDataTask *, id))success
                                     failure:(void (^)(NSURLSessionDataTask *, NSError *))failure;
</code></pre><p>—-&gt; <code>AFHTTPRequestSerializer</code> 初始化一个<code>NSMutableURLRequest</code></p>
<pre><code>- (NSMutableURLRequest *)requestWithMethod:(NSString *)method
                             URLString:(NSString *)URLString
                            parameters:(id)parameters
                                 error:(NSError *__autoreleasing *)error;
</code></pre><p>—&gt; <code>AFURLRequestSerialization</code>  配置<code>NSMutableURLRequest</code></p>
<pre><code>- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request
                           withParameters:(id)parameters
                                    error:(NSError *__autoreleasing *)error;
</code></pre><p>—-&gt; <code>AFURLSessionManager</code>  配置<code>NSURLSessionDataTask</code></p>
<pre><code>- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;
</code></pre><p>—&gt; 把<code>dataTask</code>添加到代理中</p>
<pre><code>- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask
                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
</code></pre><h5 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h5><p>先来看一下<code>AFURLSessionManager</code>类的接口文件。</p>
<pre><code>//进行下载的对话
@property (readonly, nonatomic, strong) NSURLSession *session;

//操作队列，当代理进行回调的时候使用
@property (readonly, nonatomic, strong) NSOperationQueue *operationQueue;

//数据解码
@property (nonatomic, strong) id &lt;AFURLResponseSerialization&gt; responseSerializer;

//安全策略
@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;

//网络状态管理
@property (readwrite, nonatomic, strong) AFNetworkReachabilityManager *reachabilityManager;

//正在执行的任务
@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionTask *&gt; *tasks;

//正在执行的data任务
@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDataTask *&gt; *dataTasks;

//正在执行的upload任务
@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionUploadTask *&gt; *uploadTasks;

//正在执行的download任务
@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDownloadTask *&gt; *downloadTasks;

//回调的线程 为空就默认主线程
@property (nonatomic, strong, nullable) dispatch_queue_t completionQueue;

//回调的线程组 为空则使用私有线程组
@property (nonatomic, strong, nullable) dispatch_group_t completionGroup;

//是否在后台重新创建上传任务
@property (nonatomic, assign) BOOL attemptsToRecreateUploadTasksForBackgroundSessions

//初始化session会话
- (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration

//是否取消会话
- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks;

//下面的方法就是创建任务的方法了就不介绍了

//根据任务获取上传进度
- (nullable NSProgress *)uploadProgressForTask:(NSURLSessionTask *)task;

//根据任务获取下载进度
- (nullable NSProgress *)downloadProgressForTask:(NSURLSessionTask *)task;

//下面又是session代理方法的回调了
</code></pre><p>这就是<code>AFURLSessionManager</code>的接口文件，接下来我们看一下实现文件。<br>接口文件一开始就是一些创建线程和线程做的方法，定义一些<code>key</code>和<code>block</code>回调。</p>
<h6 id="AFURLSessionManagerTaskDelegate"><a href="#AFURLSessionManagerTaskDelegate" class="headerlink" title="AFURLSessionManagerTaskDelegate"></a>AFURLSessionManagerTaskDelegate</h6><p>在<code>AFURLSessionManager</code>实现文件中，定义了一个<code>AFURLSessionManagerTaskDelegate</code>类。继承自<code>NSObject</code>遵守了<code>NSURLSession</code>的代理。</p>
<pre><code>//初始化方法
- (instancetype)initWithTask:(NSURLSessionTask *)task;

//持有一个manager 弱引用
@property (nonatomic, weak) AFURLSessionManager *manager;

//存放下载数据
@property (nonatomic, strong) NSMutableData *mutableData;

//上传进度
@property (nonatomic, strong) NSProgress *uploadProgress;

//下载进度
@property (nonatomic, strong) NSProgress *downloadProgress;

//下载失败URL
@property (nonatomic, copy) NSURL *downloadFileURL;

//回调block
@property (nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;
@property (nonatomic, copy) AFURLSessionTaskProgressBlock uploadProgressBlock;
@property (nonatomic, copy) AFURLSessionTaskProgressBlock downloadProgressBlock;
@property (nonatomic, copy) AFURLSessionTaskCompletionHandler completionHandler;
</code></pre><p>初始化方法中，初始化了下载数据、上传下载进度，和为进度添加了一个代理。剩下就是<code>NSURLSession</code>一系列的代理方法。后面再说吧。。<br>TODO:</p>
<hr>
<h6 id="AFURLSessionTaskSwizzling"><a href="#AFURLSessionTaskSwizzling" class="headerlink" title="_AFURLSessionTaskSwizzling"></a>_AFURLSessionTaskSwizzling</h6><p>在<code>AFURLSessionManager</code>实现文件中，还定义了一个<code>_AFURLSessionTaskSwizzling</code>类。这就是Runtime中的黑魔法，进行方法交换。</p>
<pre><code>//交换方法
static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) {
    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);
    method_exchangeImplementations(originalMethod, swizzledMethod);
}

//添加方法
static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) {
    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));
}

//当该类在Runtime编译的时候运行的方法，主要重新写NSURLSession的resume和suspend方法，调用该方法的时候发出代理
+ (void)load {
  //这段代码是解决iOS7、iOS8中的方法，源码中有详细的介绍 就是交换resume方法
    if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) {
        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
        NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;
        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];
#pragma clang diagnostic pop
        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));
        Class currentClass = [localDataTask class];

        while (class_getInstanceMethod(currentClass, @selector(resume))) {
            Class superClass = [currentClass superclass];
            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));
            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));
            if (classResumeIMP != superclassResumeIMP &amp;&amp;
                originalAFResumeIMP != classResumeIMP) {
                [self swizzleResumeAndSuspendMethodForClass:currentClass];
            }
            currentClass = [currentClass superclass];
        }

        [localDataTask cancel];
        [session finishTasksAndInvalidate];
    }
}
</code></pre><h6 id="AFURLSessionManager-1"><a href="#AFURLSessionManager-1" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h6><pre><code>//初始化方法，设置会话的配置
- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {
    self = [super init];
    if (!self) {
        return nil;
    }

    if (!configuration) {
        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
    }

    self.sessionConfiguration = configuration;

    self.operationQueue = [[NSOperationQueue alloc] init];
    self.operationQueue.maxConcurrentOperationCount = 1;

    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];

    self.responseSerializer = [AFJSONResponseSerializer serializer];

    self.securityPolicy = [AFSecurityPolicy defaultPolicy];

#if !TARGET_OS_WATCH
    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];
#endif

    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];

    self.lock = [[NSLock alloc] init];
    self.lock.name = AFURLSessionManagerLockName;

    //把当前session的task 添加到AFURLSessionManagerTaskDelegate中
    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
        for (NSURLSessionDataTask *task in dataTasks) {
            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];
        }

        for (NSURLSessionUploadTask *uploadTask in uploadTasks) {
            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];
        }

        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) {
            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];
        }
    }];

    return self;
}
</code></pre><p>接下来我们看看是如何把当前的<code>task</code>用<code>AFURLSessionManagerTaskDelegate</code>储存的。</p>
<pre><code>- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask
                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
{
    //根据当前的dataTask初始化一个AFURLSessionManagerTaskDelegate
    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];
    delegate.manager = self;
    delegate.completionHandler = completionHandler;

    dataTask.taskDescription = self.taskDescriptionForSessionTasks;
    //把当前的delegate 存入mutableTaskDelegatesKeyedByTaskIdentifier
    [self setDelegate:delegate forTask:dataTask];

    delegate.uploadProgressBlock = uploadProgressBlock;
    delegate.downloadProgressBlock = downloadProgressBlock;
}


- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate
            forTask:(NSURLSessionTask *)task
{
    NSParameterAssert(task);
    NSParameterAssert(delegate);

    //线程锁
    [self.lock lock];
    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;
    //添加监听
    [self addNotificationObserverForTask:task];
    [self.lock unlock];
}

//监听当前的task开始和挂起
- (void)addNotificationObserverForTask:(NSURLSessionTask *)task {
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];
}
</code></pre><p>添加<code>uploadTask</code>和<code>downloadTask</code>方法实现相同，就不介绍了。接下来我们来看上面提到AFNetworking实现的方法。</p>
<pre><code>- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                            completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
{
    return [self dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:completionHandler];
}

- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                           uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
                         downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
                        completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler {

__block NSURLSessionDataTask *dataTask = nil;
//生成dataTask
url_session_manager_create_task_safely(^{
    dataTask = [self.session dataTaskWithRequest:request];
});

//把当前的dataTask封装成delegate 放在mutableTaskDelegatesKeyedByTaskIdentifier中，上面已经介绍过
[self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];

return dataTask;
}
</code></pre><p><code>upload</code>和<code>download</code>方法相似。</p>
<p>获取下载进度：</p>
<pre><code>- (NSProgress *)uploadProgressForTask:(NSURLSessionTask *)task {
    return [[self delegateForTask:task] uploadProgress];
}

- (NSProgress *)downloadProgressForTask:(NSURLSessionTask *)task {
    return [[self delegateForTask:task] downloadProgress];
}

- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task {
NSParameterAssert(task);

AFURLSessionManagerTaskDelegate *delegate = nil;
//线程锁
[self.lock lock];
//从mutableTaskDelegatesKeyedByTaskIdentifier取出当前的delegate
delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];
[self.lock unlock];

return delegate;
}
</code></pre><p>后面还有设置代理回调的block，我就不说了。</p>
<ul>
<li>NSURLSessionDelegate</li>
</ul>
<pre><code>//当前的session为无效的代理
- (void)URLSession:(NSURLSession *)session
didBecomeInvalidWithError:(NSError *)error
{   
    if (self.sessionDidBecomeInvalid) {
        self.sessionDidBecomeInvalid(session, error);
    }
    //发送当前失效的通知
    [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];
}

/*进行HTTPS请求的时候会调用
* 处理服务器返回的证书，需要在该方法中告诉系统是否需要安装证书
* NSURLAuthenticationChallenge : 授权质问
* NSURLSessionAuthChallengeDisposition : 保护控件
* NSURLCredential : 服务器返回的证书
*/
/* 看一下苹果解释：
如果已实现，则在发生连接级别身份验证质询时，此代理将有机会向基础连接提供身份验证凭据。
某些类型的身份验证将应用于与服务器的给定连接上的多个请求（SSL服务器信任质询）。
如果未实现此委托消息，则行为将使用默认处理，这可能涉及用户交互
*/
//这个方法目前没用到过
- (void)URLSession:(NSURLSession *)session
didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler
{
    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;
    __block NSURLCredential *credential = nil;

    //判断当前sessionDidReceiveAuthenticationChallenge回调是否存在存在则回调 不存在这安全策略则进行服务器信任。
    if (self.sessionDidReceiveAuthenticationChallenge) {
        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);
    } else {
        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {
                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
                if (credential) {
                    disposition = NSURLSessionAuthChallengeUseCredential;
                } else {
                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;
                }
            } else {
                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;
            }
        } else {
            disposition = NSURLSessionAuthChallengePerformDefaultHandling;
        }
    }

    if (completionHandler) {
        completionHandler(disposition, credential);
    }
}
</code></pre><ul>
<li>NSURLSessionTaskDelegate</li>
</ul>
<pre><code>// 告诉委托远程服务器请求HTTP重定向。
//此方法仅适用于默认和临时会话中的任务。 后台会话中的任务会自动遵循重定向。
- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
willPerformHTTPRedirection:(NSHTTPURLResponse *)response
        newRequest:(NSURLRequest *)request
 completionHandler:(void (^)(NSURLRequest *))completionHandler
{
    NSURLRequest *redirectRequest = request;

    if (self.taskWillPerformHTTPRedirection) {
        redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request);
    }

    if (completionHandler) {
        completionHandler(redirectRequest);
    }
}


//和上面NSURLSessionDelegate相同
- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler
{
    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;
    __block NSURLCredential *credential = nil;

    if (self.taskDidReceiveAuthenticationChallenge) {
        disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);
    } else {
        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {
                disposition = NSURLSessionAuthChallengeUseCredential;
                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
            } else {
                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;
            }
        } else {
            disposition = NSURLSessionAuthChallengePerformDefaultHandling;
        }
    }

    if (completionHandler) {
        completionHandler(disposition, credential);
    }
}

//当任务需要新的请求主体流发送到远程服务器时，告诉委托。
//这种委托方法在两种情况下被调用：
//1、如果使用uploadTaskWithStreamedRequest创建任务，则提供初始请求正文流：
//2、如果任务因身份验证质询或其他可恢复的服务器错误需要重新发送包含正文流的请求，则提供替换请求正文流。
 注：如果代码使用文件URL或NSData对象提供请求主体，则不需要实现此功能。

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
 needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler
{
    NSInputStream *inputStream = nil;

    if (self.taskNeedNewBodyStream) {
        inputStream = self.taskNeedNewBodyStream(session, task);
    } else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) {
        inputStream = [task.originalRequest.HTTPBodyStream copy];
    }

    if (completionHandler) {
        completionHandler(inputStream);
    }
}

//定期通知代理向服务器发送主体内容的进度。也就是当前的上传进度
- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
   didSendBodyData:(int64_t)bytesSent
    totalBytesSent:(int64_t)totalBytesSent
totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend
{

    int64_t totalUnitCount = totalBytesExpectedToSend;
    if(totalUnitCount == NSURLSessionTransferSizeUnknown) {
        NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@&quot;Content-Length&quot;];
        if(contentLength) {
            totalUnitCount = (int64_t) [contentLength longLongValue];
        }
    }

    //获取当前delegate
    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];

    //如果delegate存在 则调用delegate中的代理方法，回调进度
    if (delegate) {
        [delegate URLSession:session task:task didSendBodyData:bytesSent totalBytesSent:totalBytesSent totalBytesExpectedToSend:totalBytesExpectedToSend];
    }

    //如果block存在则回调
    if (self.taskDidSendBodyData) {
        self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount);
    }
}

//回调任务完成，数据传输完成
- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
didCompleteWithError:(NSError *)error
{
    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];

    // delegate may be nil when completing a task in the background
    if (delegate) {
        [delegate URLSession:session task:task didCompleteWithError:error];

        //移除delegate
        [self removeDelegateForTask:task];
    }

    //回调
    if (self.taskDidComplete) {
        self.taskDidComplete(session, task, error);
    }
}
</code></pre><ul>
<li>NSURLSessionDataDelegate</li>
</ul>
<pre><code>//告诉delegate已经接受到服务器的初始应答, 准备接下来的数据任务的操作.
- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
didReceiveResponse:(NSURLResponse *)response
 completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler
{
    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;

    //回调
    if (self.dataTaskDidReceiveResponse) {
        disposition = self.dataTaskDidReceiveResponse(session, dataTask, response);
    }

    if (completionHandler) {
        completionHandler(disposition);
    }
}


//告诉代理数据任务已更改为下载任务
- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask
{
  //获取delegate
    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];
    if (delegate) {
      //如果delegate存在则移除 储存downloadTask
        [self removeDelegateForTask:dataTask];
        [self setDelegate:delegate forTask:downloadTask];
    }

    //回调
    if (self.dataTaskDidBecomeDownloadTask) {
        self.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask);
    }
}

//收到数据的时候回调
- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
    didReceiveData:(NSData *)data
{
    //获取delegate 并调用delegate中的会话代理方法
    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];
    [delegate URLSession:session dataTask:dataTask didReceiveData:data];

    //回调
    if (self.dataTaskDidReceiveData) {
        self.dataTaskDidReceiveData(session, dataTask, data);
    }
}

//询问委托数据（或上传）任务是否应将响应存储在缓存中。
- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
 willCacheResponse:(NSCachedURLResponse *)proposedResponse
 completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler
{
    NSCachedURLResponse *cachedResponse = proposedResponse;

    if (self.dataTaskWillCacheResponse) {
        cachedResponse = self.dataTaskWillCacheResponse(session, dataTask, proposedResponse);
    }

    if (completionHandler) {
        completionHandler(cachedResponse);
    }
}

//会话进入后台调用的代理
- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session {
    if (self.didFinishEventsForBackgroundURLSession) {
        dispatch_async(dispatch_get_main_queue(), ^{
            self.didFinishEventsForBackgroundURLSession(session);
        });
    }
}
</code></pre><ul>
<li>NSURLSessionDownloadDelegate</li>
</ul>
<pre><code>//下载完成调用存放在临时文件路径
- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location
{   
  //获取当前delegate
    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];
    if (self.downloadTaskDidFinishDownloading) {
      //获取fileURl
        NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);
        if (fileURL) {
            delegate.downloadFileURL = fileURL;
            NSError *error = nil;

            //把临时文件移到目标地址
            if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error]) {
                //发送通知
                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];
            }

            return;
        }
    }

    if (delegate) {
      //调用delegate中的代理方法················
        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];
    }

    //下载进度代理方法
    - (void)URLSession:(NSURLSession *)session
          downloadTask:(NSURLSessionDownloadTask *)downloadTask
          didWriteData:(int64_t)bytesWritten
     totalBytesWritten:(int64_t)totalBytesWritten
    totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
    {

        AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];
        //调用delegate中的代理方法················
        if (delegate) {
            [delegate URLSession:session downloadTask:downloadTask didWriteData:bytesWritten totalBytesWritten:totalBytesWritten totalBytesExpectedToWrite:totalBytesExpectedToWrite];
        }

        //回调
        if (self.downloadTaskDidWriteData) {
            self.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
        }
    }

    //断点续下载
    - (void)URLSession:(NSURLSession *)session
          downloadTask:(NSURLSessionDownloadTask *)downloadTask
     didResumeAtOffset:(int64_t)fileOffset
    expectedTotalBytes:(int64_t)expectedTotalBytes
    {

        AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];

        if (delegate) {
            [delegate URLSession:session downloadTask:downloadTask didResumeAtOffset:fileOffset expectedTotalBytes:expectedTotalBytes];
        }

        if (self.downloadTaskDidResume) {
            self.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes);
        }
    }
</code></pre><p>这就是<code>AFURLSessionManager</code>完整的实现文件。作用很明显</p>
<blockquote>
<blockquote>
<p>1、创建管理NSURLSession<br>2、管理所有Task<br>3、实现 NSURLSessionDelegate 等协议中的代理方法<br>4、引入安全策略和网络监听等</p>
</blockquote>
</blockquote>
<h4 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h4>
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/0-1/" rel="tag"># 0.1</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/18/SDWebImage源码阅读/" rel="next" title="SDWebImage源码阅读">
                <i class="fa fa-chevron-left"></i> SDWebImage源码阅读
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/24/iOS多线程开发-NSOperation/" rel="prev" title="iOS多线程开发_NSOperation">
                iOS多线程开发_NSOperation <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Robert Lee</p>
              <p class="site-description motion-element" itemprop="description">Robert Lee的博客</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#AFNetworking-3-2-1"><span class="nav-number">1.</span> <span class="nav-text">AFNetworking 3.2.1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSURLConnection"><span class="nav-number">2.</span> <span class="nav-text">NSURLConnection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NSURLConnectionDelegate"><span class="nav-number">2.1.</span> <span class="nav-text">NSURLConnectionDelegate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSURLConnectionDataDelegate"><span class="nav-number">2.2.</span> <span class="nav-text">NSURLConnectionDataDelegate</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSURLSession"><span class="nav-number">3.</span> <span class="nav-text">NSURLSession</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NSURLSessionConfiguration-类"><span class="nav-number">3.1.</span> <span class="nav-text">NSURLSessionConfiguration 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSURLSession-类"><span class="nav-number">3.2.</span> <span class="nav-text">NSURLSession 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AFNetworking"><span class="nav-number">3.3.</span> <span class="nav-text">AFNetworking</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AFNetworking-简单使用"><span class="nav-number">3.4.</span> <span class="nav-text">AFNetworking 简单使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AFURLSessionManager"><span class="nav-number">3.4.1.</span> <span class="nav-text">AFURLSessionManager</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#AFURLSessionManagerTaskDelegate"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">AFURLSessionManagerTaskDelegate</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#AFURLSessionTaskSwizzling"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">_AFURLSessionTaskSwizzling</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#AFURLSessionManager-1"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">AFURLSessionManager</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AFHTTPSessionManager"><span class="nav-number">3.5.</span> <span class="nav-text">AFHTTPSessionManager</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Robert Lee</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
